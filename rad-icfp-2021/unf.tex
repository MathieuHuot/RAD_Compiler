\section{UNF}
\label{sec:unf}

Following the intuition highlighted in Section~\ref{subsec:insights}, 
we present a new language which we call unary form (UNF). 
There is a Source UNF for the Source language and a Target UNF for the Target language.
Just as Target is an extension of Source, Target UNF is an extension of Source UNF.

One takeaway from this paper is that efficient pure reverse-mode is complicated because of the several things it does.
It goes through the term and keeps a store for the gradients to be updated. 
It keeps track of the new bound variables found while going through the term.
The updates to the gradient are done via pre-composition and not post-composition.
Due to the linearity requirement in the usage of the continuation variable, 
it needs to process like a call-by-value evaluation and evaluate the arguments of operators in a certain order before 
dealing with the operator itself.

By introducing UNF, we are trying to decouple some of the problems.
UNF introduces the call-by-value evaluation of the arguments before evaluating the arguments and a good management of the environment.
Differentiation on UNF deals with the purely functional store and gradients update via pre-composition.
Finally, going back from UNF to Target uses the stored information in UNF to make sure the Jacobians are computed efficiently. 

\subsection{Source UNF} % (fold)
\label{sub:Source UNF}

Intuitively, a term consists of a composition of unary operators. 
To compile our source language to this intermediate representation, 
we need to remember some information about the context of the initial term. 
The grammar of Source UNF is given in Figure~\ref{fig:unf_source_grammar}. 

\input{figures/source_unf}

There are a few notable things in this syntax. 
Every primitive is indexed by a list of types from the source language, 
which corresponds to a context being carried. 
Every constant, unary, or binary operator from Source has a corresponding $n$-ary operator !op$_{T,n}$! in UNF.
Sequential composition is denoted by !;! and !e$_{1}$;e$_{2}$! means that !e$_{1}$! should be performed, and then !e$_{2}$!.
The array operators !map2! and !reduce! have extra indices that represent well-formed terms in Source.
The language has a second kind of sequential composition, which we call passing sequential compsition $\pcomp$.
In !e$_{1}$ $\pcomp$ e$_{2}$! the idea is first that !e$_{1}$! is computed, followed by !e$_{2}$!. 
However, !e$_{1}$! outputs an argument which is not used by !e$_{2}$! and is just passed by !e$_{2}$! 
along and returned with the output of !e$_{2}$!.
The language also contains a projection !proj! which forgets some of the elements, 
and a pairing operator !pair! which takes the last pair of elements and returns the pairing of these elements.

The typing rules are detailed in Figure~\ref{fig:source_unf_typesystem}.
$\reals^{\times n}$ is a notation for $\reals,\ldots,\reals$ with $n$ factors $\reals$.

\input{figures/source_unf_typesystem}

\begin{example}
    !cos$_{\reals,\reals}$ $\comp$ pair$_{\reals,\reals; \reals\times\reals}$! 
    represents !x$_1$:$\reals$, x$_2$:$\reals$, x$_3$:$\reals$ $\vdash$ let (x$_1$,x$_2$,x$_3$,x$_4$)=(x$_1$,x$_2$,x$_3$,cos(x$_3$)) in (x$_1$,x$_2$,<x$_3$,x$_4$>)!.
    $\comp$ can more generally be understood as a let binding of a tuple, and primitives only act on the last parts of the tuple, always returning the context.
\end{example}

\subsection{Target UNF} % (fold)
\label{sub:Target UNF}

The Target UNF is an extension of Source UNF. 
Its types are lists of types of Target. 
Higher-order types are needed for the continuation introduced by reverse-mode. 
In addition, it contains several new primitives which represent the transpose Jacobian of the primitives of Source UNF.
Lastly, Target UNF has an internal composition $\icomp$. 
!e$_{1}$ $\icomp$ e$_{2}$! represents precomposition of a curried function !e$_{1}$! by a term !e$_{2}$!
It is used by the reverse-mode transformation to pre-compose the continuation term by a transpose Jacobian.
The grammar of Target UNF is given in Figure~\ref{fig:unf_source_grammar} and its type system in Figure~\ref{fig:target_unf_typesystem}.

\input{figures/target_unf}

\input{figures/target_unf_typesystem}

\subsection{Simple reverse mode transformation} % (fold)
\label{sub:Simple reverse mode transformation}

We are now able to present a simpler transformation for purely functional reverse-mode from Source UNF to Target UNF.
The differentiation transformation is given in Figure~\ref{fig:diff_macro}.
To a list of types, the transformation adds a higher-order type. 
It is to be understood as the continuation for the pure storage of the gradient.
On primitive constants of Source UNF, it returns a pair. 
The first part is the initial term (pre-composed by a projection because it is not using the continuation variable).
The second part returns the continuation term pre-composed by the transpose Jacobian of the primitive.

\input{figures/macro_diff}

\subsection{transformations to and from UNF} % (fold)
\label{sub:transformations to and from UNF}

We give a translation from our Source to Source UNF in Figure~\ref{fig:source_to_unf}.

TODO:redo

UNF acts as a sort of stack. 
The input represents the current stage of the stack, and we return the new value added to the stack.
All results are kept, so the stack keeps growing. One might be surprised that the transformation for pairs and let is similar.
The order of UNF really follows what the trace of doing a sequential call-by-value evaluation would look like if the return value does not matter.
In other words, when evaluating !let x= e1 in e2! in call by value, we first evaluate !e1! and then !e2!. 
Similarly in !<e1, e2>!, we evaluate !e1! and then !e2!. 
Our ultimate goal is to return a gradient, not the original term, so what really matters is the order of evaluation, and what is evaluated.

TODO: need to explain that return values produce some kind of ANF and introduce new vars.

\input{figures/source_to_unf}

The transformation from the target UNF to the target language is presented in Figure~\ref{fig:unf_to_target}.

\input{figures/unf_to_target}

