\section{Unary Form}

Following the previous insight, we change the interpretation of terms. 

Note that every ground type $G$ inherits a pointwise monoid structure from $\reals$ and has zero element $\overline{0}$.
We need a few  more notations.

\begin{notation}
	\begin{itemize}
		\item If $\Gamma\vdash \trm:A$ and $\Delta$ is another context, then $\Gamma,\Delta\vdash \widetilde{\trm}:A$ is the weakening of $\trm$.
		\item If $\Gamma\vdash \trm:A$, $\Delta$ another context and $\Delta'$ is a \underline{ground} context, then  $\Gamma,\Delta\vdash \widehat{\trm}:A\times \Delta'$ where $\widehat{\trm}:= \tPair{\widetilde{\trm}}{\overline{0}}$
	\end{itemize}
\end{notation}

The new idea simply consists in changing each operation so that it takes a single argument (a vector). To do that, each operation returns its arguments in addition to its return value. 

We see $\UNF{-}$ as a transformation (not a functor) from $\SSSyn$ to $\TSSyn$, which we describe now. We also denote by $\TSSyn$ the syntactic category of the language. It is a first-order language with $n$-ary products, sums, composition $;$, and the following primitives. For each operator $\op_n:\RR^n\to \RR$ and each type $\Gamma$, we have a primitive operator $\op_{n,\Gamma}:\Gamma\times \RR^n\to \Gamma\times \RR^n\times \RR$. For each type $\Gamma=A_1\times...\times A_n$, we also have a primitive $var_{i,\Gamma}:\Gamma\to \Gamma\times A_i$. 

\[
\begin{array}{cc}
	\inferrule{~}{\Gamma=A_1\times\ldots \times A_n\vdash var_{i,\Gamma}: \Gamma\times A_i }(A_i\in G(\reals))
	& \inferrule{~}{\Gamma\times \RR^n \vdash \op_{n,\Gamma}: \Gamma\times \RR^n\times \RR }\\
	\inferrule{A \vdash \trm: B \quad B \vdash \trm[2]: C}{A\vdash \trm;\trm[2]:C} 
	& \inferrule{\Gamma,b:\BB\vdash\trm:\BB\quad \Gamma \vdash \trm_1,\trm_2:A }{\Gamma,b:\BB\vdash \ifelse{\trm}{\trm_1}{\trm_2}:A}\\
	\inferrule{\Gamma\vdash \trm:A \quad \Delta\in G(\reals)}{\Gamma\vdash \widehat{\trm}:A\times \Delta }
	& \inferrule{\Gamma\vdash \trm: A_1\times\ldots A_k}{\Gamma\vdash swap_\sigma(\trm):A_{\sigma(1)}\times\ldots A_{\sigma(k)}}(\sigma\text{ permutation})\\
	\inferrule{~}{\Gamma,b:\BB,\Gamma'\vdash b:\BB}
	&\inferrule{~}{\Gamma,n:\NN,\Gamma'\vdash b:\NN}
\end{array}
\]
The idea is that we are linear in the real-based types and classical on boolean and integer types. This comes from the fact that the derivative of the latter being trivial, we don't need to properly keep track of them to avoid fanout.

Let $G(\reals)$ be a ground type based on reals (not booleans nor integers). It is defined by the following grammar:
\[G(\reals):=\reals \,\gor\, G(\reals)\times\ldots \times G(\reals)\,\gor\,\Array{G(\reals)}\]

We define the transformation $\UNFSymbol$ inductively as follows:
\begin{itemize}
	\item $\UNF{\Gamma\vdash \var_i: G(\reals)}:=var_{i,\Gamma}$
	\item $\UNF{\Gamma\vdash \var_i: \BB\text{ or }\NN}:=\var_i:\BB\text{ or }\NN$
	\item $\UNF{\op_n(\trm_1,\ldots,\trm_n)}:=\UNF{\tTuple{\trm_1,\ldots,\trm_n}}:\Gamma'\times \RR^n;\op_{n,\Gamma'}$
	\item $\UNF{\letin{\var}{\trm}{\trm[2]}}:=\UNF{\trm};\UNF{\widetilde{\trm[2]}}$
	\item $\UNF{\tTuple{\trm_1,\ldots,\trm_n}}:=\UNF{\trm_1};\ldots;\UNF{\widetilde{\trm_n}};swap_\sigma$ where $\UNF{\widetilde{\trm_i}}:\Gamma\times \Delta_1\times A_1 \times \Delta_2 \times A_2\times\ldots \times \Delta_i \times A_i$, $\trm_i:A_i$ and $swap_\sigma:\Gamma\times\Delta_1 \times \ldots \times A_n: \Gamma\times \Delta_1\times\ldots\times\Delta_n\times A_1\times\ldots\times A_n$
	\item $\UNF{\tMatch{\trm}{\var_1,\ldots,\var_n}{\trm[2]}}:=\UNF{\trm};\UNF{\widetilde{\trm[2]}}$
	%\item $\UNF{\ifelse{\trm}{\trm[2]_1}{\trm[2]_2}}:=\ifelse{\UNF{\trm}}{\widehat{\UNF{\widetilde{\trm[2]_1}}};swap_\sigma}{\widehat{\UNF{\widetilde{\trm[2]_2}}};swap_\mu}$ where $swap_\sigma:\Gamma\times \Delta_1\times A \times \Delta_2\to \Gamma\times \Delta_1\times \Delta_2 \times A$ and $swap_\mu:\Gamma\times \Delta_2\times A \times \Delta_1\to \Gamma\times \Delta_1\times \Delta_2 \times A$
\end{itemize}

We denote by $\semu{-}:\TSSyn\to \SSSyn$ the identity-on-objects functor given as follows:
\begin{itemize}
	\item  $\semu{var_{i,\Gamma}}:=\var:\Gamma\vdash \tMatch{\var}{\var_1,\ldots,\var_n}{\tTuple{x_1,\ldots,x_n,x_i}}$
	\item $\semu{\op_{n,\Gamma}}:=\var:\Gamma\times\RR^n\vdash \tMatch{\var}{\var_1,\var_2}{\tTuple{\var_1,\var_2,\op_n(\var_2)}}$
	\item $\semu{\trm;\trm[2]}:=\letin{\var}{\semu{\trm}}{\semu{\trm[2]}}$
	\item $\semu{swap_\sigma}:=\var:A_1\times\ldots\times A_n\vdash\tMatch{\var}{\var_1,\ldots\var_n}{\tTuple{\var_{\sigma(1)},\ldots,\var_{\sigma(n)}}}$
	\item $\semu{b:\BB\text{ or }\NN}:=\var:\Gamma\times (\BB\text{ or }\NN)\vdash\tMatch{\var}{\var[2],b}{b:\BB\text{ or }\NN}$
	\item $\semu{\widehat{\trm}}:=\letin{\var}{\semu{\trm}}{\tPair{x}{\underline{0}}}$
	%\item $\semu{\ifelse{\trm}{\trm_1}{\trm_2}}=\ifelse{\semu{\trm}}{\semu{\trm_1}}{\semu{\trm_2}}$
\end{itemize}

\begin{proposition}
	Let $\Gamma\vdash \trm:\ty$.\\ 
	Then $\Gamma\vdash \UNF{\trm}:\Gamma\times \Delta\times \ty$, where $\Delta$ is the list of bound variables of $\trm$.
	In addition, $\pi_{\Gamma\times \Delta}(\sem{\trm})=id$ and $\pi_{\ty}(\sem{\trm})=\sem{\trm}$. 
\end{proposition}

\begin{proposition}
	$\pi_{last}(\UNF(\trm))=\trm$ where the equality is modulo $\alpha,\beta,\eta$ and some classical algebraic rules.
\end{proposition}

The composition of the 3 transformations from before can be written more compactly and more efficiently into 1 step, by adding a bit of extra information to the reverse-mode transformation. 

Semantically, we have the following diagram.\\
\begin{tikzcd}
	& \Dsynrev[\rho]{\reals^n} 
	\ar[rr,"\overleftarrow{\mathcal{D}}_{\rho}(\UNF{\trm})"] 
	\ar[rr, phantom, bend right=10, " "{name=D}, near end]
	\ar[rr, phantom, bend right=10, " "{name=F}, near start]  
	\ar[dd, "\pi", near start] \ar[dl, equal]
	& & \Dsynrev[\rho]{\reals^m\times\reals} 
	\ar[dd,"\pi"] 
	\\
    \Dsynrev[\rho]{\reals^n} 
    \ar[rr, crossing over,"\overleftarrow{\mathcal{D}}_{\rho}^*(\UNF{\trm})"', near end] \ar[dd, "\pi"']
    \ar[rr, phantom, bend left=10, ""{name=E}, near end]
    \ar[rr, phantom, bend right=20, ""{name=G}, near start]  
    & & \Dsynrev[\rho]{\reals}  & \\
    & \reals^n \ar[dl,equal] 
    \ar[rr,"\UNF{\trm}", near start] 
    \ar[rr,bend right=10, phantom, near start," "'{name=A}]
    \ar[rr, phantom, bend left=10, " "{name=C}, near end] 
    & & \reals^m\times\reals \ar[dl, "\pi_2"] \\
    \reals^n 
    \arrow[rr,"\trm"'] 
    \ar[rr, phantom, bend left=10," "{name=B}]
    \ar[rr, phantom, bend left=10," "{name=H}, near start] 
    & & \reals  
    \arrow[from=uu, near start, crossing over, "\pi"] 
    & \arrow[Rightarrow, color=blue, from=B, to=A, "\UNF{-}"']
    \arrow[Rightarrow, color=blue, from=C, to=D, "\overleftarrow{\mathcal{D}}"', bend right=20]
     \arrow[Rightarrow, near start, color=blue, from=F, to=E, "\UNF{-}^{-1}"]
      \arrow[Rightarrow, color=red, from=G, to=H, "\overleftarrow{\mathcal{D}}^*"', bend right=10, crossing over]
    \ar[from=1-4, to=2-3, "\pi_{\reals\times (\reals^m\times \reals\to \rho)}", crossing over]
\end{tikzcd}\\
Of course, the point is that in practice we can run it faster, while keeping correctness.

This macro can also directly perform some of the later optimisations, like the better expression for the Jacobian.