\begin{abstract}
    We introduce an efficient source-code transformation for reverse-mode differentiation on an expressive purely functional language that does not introduce mutation.
    We show that our transformation is correct and verifies the cheap gradient principle. 
    Our transformation is presented as a compilation scheme through a novel intermediate representation we call unary form.
    We obtain provably efficient gradients by performing general partial evaluation optimisations after our reverse-mode transformation as opposed to hand-crafted ones.
    For simple first-order programs, the obtained outputs look like static single assignment (SSA) code. 
    For arrays, our transformation preserves parallelism as much as possible. 
    Our work emphasizes modularity and our language can easily be enriched with more optimised primitives as required for some speedups in practice.
\end{abstract}