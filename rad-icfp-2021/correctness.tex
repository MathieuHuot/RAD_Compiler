\section{Correctness}
\label{sec:correctness}

This section provides a categorical analysis of our language and transformations.
The end result is the correctness of the reverse mode transformation from Section~\ref{sub:Macro for pure reverse mode transformation}:

 \begin{theorem}
     For every $\Gamma \vdash$ !e:!$\reals$, we have 
     $\sem{\grad_\Gamma e}= \grad_\Gamma\sem{e}$.
 \end{theorem}
where $\sem{-}$ is an appropriate denotational semantics of smooth functions.

\subsection{Denotational semantics source and Target} % (fold)
\label{sub:Denotational semantics source and Target}

It is standard to give a denotational semantics of a first-order language in a Cartesian category.
An alternative approach consists of giving semantics in a multicategory.
A multicategory generalizes a category by allowing multimorphisms, that is, morphisms from a list of objects to an object.
Most categorical structures from category theory can be phrases similarly in multicategories.

In terms of semantics, a term $x_1:A_1,\ldots,x_n:A_n\vdash e:A$ is interpreted as a morphism $\sem{e}:[\sem{A_1},\ldots,\sem{A_n}]\to \sem{A}$ in a multicategory.
Substitution is still interpreted as composition. 

One can consider a syntactic model for a language, which consists in a free multicategory.
Our source and target languages induce syntactic multicategories as follows.

\begin{definition}[Syntactic multicategory for Source]
    Let $\SynSource$ be the multicategory whose objects are types of Source, and where a morphism 
    $[A_1,\ldots,A_n]\to A$ is a term $x_1:A_1,\ldots,x_n:A_n\vdash e:A$ of Source modulo the $\eta\beta$-laws.
    Composition is by substitution.
\end{definition}

We similarly define $\SynTarget$, the syntactic multicategory for Target.

As is standard, $\SynSource$ satisfies the following universal property: 
for every Cartesian multicategory $\catC$ with arrays map and reduce,
and every object $F(\reals)\in\catC$ and morphisms $F(\underline{c})\in\catC(1;F(\reals))$, 
$F(op1)\in\catC(F(\reals);F(\reals))$, $F(op2)\in\catC(F(\reals),F(\reals);F(\reals))$, there is a unique
multifunctor $F:\SynSource\to\catC$ respecting the interpretation and preserving all the structure.

We can, for instance, use this to give a simple semantics of Source 
in the multicategory of Cartesian spaces and smooth maps between them. 

\begin{definition}[$\CartSp$]
Let $\CartSp$ be the Cartesian category whose objects are Euclidean spaces
and whose morphisms are smooth functions between Euclidean spaces.
TODO:it's not a multicategory yet

We can interpret Source in $\CartSp$ as follows.
    \begin{tabular}{r c l}
    $\seml \reals \semr$ & $\defeq$& $\RR$ \\
    $\seml$!T1xT2!$\semr$ & $\defeq$& $\seml$!T1!$\semr \times\seml$!T2!$\semr$ \\
    $\seml \Array{\reals}{n}\semr$ & $\defeq$ & $\prod_{1\leq i \leq n} \RR$ 
    \end{tabular}
A context $\Gamma=\{x_1:A_1,\ldots,x_n:A_n\}$ is interpreted as the product $\prod_{1\leq i \leq n}\sem{A_i}$.
Well typed terms $\Gamma\vdash$!e: !$A$ are interpreted as functions $\sem{\Gamma}\to\sem{A}$. This is
routinely defined by induction on the structure of typing derivations. Constants
!c! $\reals$ are interpreted as constant functions; and the primitives operations !op1,op2!
are interpreted by composing with the corresponding functions, which are smooth. 
Variables are interpreted as $\sem{x_i}(\rho)\defeq \rho_i$. 
The remaining constructions are interpreted as follows.
\begin{tabular}{r c l}
    $\seml$!map2 (x,y.e1) e2 e3!$\semr$ &=& TODO\\
    $\seml$!reduce (x,y.e1) e2 e3!$\semr$ &=& TODO
\end{tabular}
\end{definition}

TODO: what about semantics Target?

\subsection{Semantics for UNF using concategories} % (fold)
\label{sub:Semantics for UNF using concategories}

One main reason for introducing UNF is to have a better handle over
the computation flow of the term, similar to what ANF or CPS provide. 
A convenient categorical setting for this is to use string diagrams.
To better fit the standard denotational semantics of languages, 
we can instead use concategories. 

Concategories are a generalization of categories and multicategories in that 
they allow morphisms both from and to a list of objects. 
Similarly to categories and multicategories, 
most categorical abstractions used for the semantics of languages are easily adapted to them.

In particular, one can form a syntactic concategory, 
which satisfies a similar universal property as syntactic multicategories.
Two such examples are of particular interest for us, 
because they will allow us to interpret Source and Target UNF, 
but also explain the UNF and $UNF^{-1}$ transformations.

\begin{definition}[$\ConcatS$]
Let $\ConcatS$ the syntactic Cartesian concategory whose types are those of Source and 
with primitives given by $op1: \reals \to \reals$, $op2: \reals,\reals \to \reals$ $map2_{x,y.e}$
and $reduce_{x,y.e1;e2}$.
TODO: actually I just need projection and a representing object for pairs, it might be weaker than Cartesian? edit: I think I need Cartesian.
\end{definition}

One may notice that the syntax of $\ConcatS$ is somewhere in between the syntax of Source and of Source UNF.

\begin{notation}[Morphisms in a Cartesian concategory]
    TODO: projection, unique map, $\concatcomp$, swap, pair, id, ...
\end{notation}

We can interpret Source UNF in $\ConcatS$ as follows.

\begin{tabular}{l c l}
   $\seml$!var!$_{T;i} \semr$ &=& $<id_\Gamma,\pi_i>$ \\
   $\seml$!op!$_{T;n} \semr$ &=& $id_\Gamma\concatcomp op_n$\\
   $\seml$!pair!$_{T;A\times B} \semr$ &=& $pair_{T;A\times B}$ \\
   $\seml$!proj!$_{T1;T2;T3} \semr$ &=& $id_{T1}\concatcomp 1_{T2}\concatcomp id_{T3}$\\
   $\seml$!e1!$\comp$!e2!$\semr$  &=& $\seml$!e1!$\semr \comp \seml$!e2!$\semr$ \\
   $\seml$!e1!$\pcomp$!e2!$\semr$ &=& $\seml$!e1!$\semr \comp (\seml$!e2!$\semr\concatcomp id )\comp swap$ \\
   $\seml$!map2!$_{T;x,y.e}\semr$  &=& $id_\Gamma\concatcomp map2_{x,y.e}$ \\
   $\seml$!reduce!$_{T;x,y.e;e}\semr$ &=& $id_\Gamma\concatcomp reduce_{x,y.e1;e2}$ \\
\end{tabular}

Similarly, we introduce a second concategory for the Target part of our transformations.

\begin{definition}[$\ConcatT$]
Let $\ConcatT$ be the syntactic Cartesian concategory whose types are those of Target and 
with primitives given by 
$op1: \reals \to \reals$, 
$op2: \reals,\reals \to \reals$, 
$map2_{x,y.e}: \Array{\reals}{n},\Array{\reals}{n}\to \Array{\reals}{n}$, 
$reduce_{x,y.e1;e2}: \Array{\reals}{n} \to \Array{\reals}{n}$, 
$J^Top1: \reals \to \reals$, 
$J^Top2: \reals \to \reals, \reals$, 
$J^Tmap2_{x,y.e}: \Array{\reals}{n} \to \Array{\reals}{n}, \Array{\reals}{n}$, 
$J^Treduce_{x,y.e1;e2}: \Array{\reals}{n} \to \Array{\reals}{n}$, 
TODO: not too sure, should I say what a Cartesian concat is? do I need $J^Tproj$?
\end{definition}

We can interpret Target UNF in $\ConcatT$ as follows. 
The part common with Source UNF is interpreted in the same way as for Source UNF.

TODO: I think need to explain here the (co)monoid structure induced by $D$

\begin{tabular}{l c l}
    $\seml$!J!$^T$!var!$_{T;i} \semr$ &=& TODO \\
    $\seml$!J!$^T$!op!$_{T;n} \semr$ &=&  \\
    $\seml$!J!$^T$!pair!$_{T;A\times B} \semr$ &=& \\
    $\seml$!J!$^T$!proj!$_{T1;T2;T3} \semr$ &=& \\
    $\seml$!J!$^T$!map2!$_{T;x,y.e}\semr$  &=& \\
    $\seml$!J!$^T$!reduce!$_{T;x,y.e;e}\semr$  &=& \\
    $\seml$!<e1, e2>!$\semr$  &=& !<!$\seml$!e1!$\semr$, $\seml$!e2!$\semr$!>! \\
    $\seml$!e1!$\icomp$!e2!$\semr$ &=&  \\
 \end{tabular}
TODO: Do I need any kind of proposition saying that this makes sense?
Might need to define on types as well to be clearer: It's an identity on types functor...

\subsection{Semantics for UNF transformations} % (fold)
\label{sub:Semantics for UNF transformations}

We interpret Source in a new multicategory, 
whose morphisms are particular morphisms of $\ConcatS$.
As Source UNF is itself interpreted in $\ConcatS$, 
this gives us a way to compare terms in Source with terms in Source UNF.
This comparison precisely gives the UNF transformation.

\begin{definition}[Mutlicat from concat]
    A multicategory $\catC$ naturally defines a concategory with the same objects as $\catC$ and
    with morphisms $A\to [B_1,\ldots,B_n]$ being $n$ morphisms $A\to Bi$ of $\catC$. 
\end{definition}

\begin{proposition}[construction above gives UNF]
    TODO
\end{proposition}

In a similar vein, we form a concategory from the syntactic multicategory for Target.
We then use the universal property of $\ConcatT$ to construct a functor from $\ConcatT$ to this concategory.
This allows us to compare the terms of Target UNF and the terms of Target. 
$UNF^-1$ arises in this way.

\begin{definition}[Concat from multicat]
    TODO
\end{definition}

\begin{proposition}[Initiality of concat2 gives $UNF^-1$]
    TODO
\end{proposition}

What remains to explain now is the reverse mode transformation between Source UNF and Target UNF.
We construct a functor $D:\ConcatS\to\ConcatT$. 
This functor will easily be shown to compute reverse-mode derivatives.
Because terms of Source UNF in $\ConcatS$, we observe the effect of $D$ on them
and show that it matches the syntactic $\Dsynrevsymbol_{\rho}$ 
from Section~\ref{sub:Simple reverse mode transformation}.

\begin{definition}[D as a lax functor]
    TODO
\end{definition}

\begin{proposition}[semantic of syntactic D matches D lax functor]
    TODO
\end{proposition}


\subsection{Correctness theorem} % (fold)
\label{sub:Correctness theorem}

First, we start from the correctness of $\Dsynrevsymbol_{\rho}$:Source UNF $\to$ Target UNF, which is easy to establish, 
and then propagate this information to Source and Target via the $\UNFSymbol, \UNFSymbol^{-1}$ transformations.

\begin{proposition}[Correctness $\Dsynrevsymbol_{\rho}$]
    For every term !$\reals^{\times n} \vdash$ e: $\reals^{\times n+1}$! in Source UNF,\\ 
    $\pi_2 \seml \Dsynrevsymbol_{\rho}$!e!$\semr(x_1,\ldots x_n,Id_{\RR^n})$=$J^T_{(x_1,\ldots x_n)}\seml$!e!$\semr$.
\end{proposition}

This is routinely proved by induction as the language is first-order. 
This uses the fact that for every primitive constant $A$, $\sem{J^TA}=J^T\sem{A}$.

Recall that the intuition from Source UNF is that it consists of terms of Source that also return their context.
From there, the intuition for the Jacobian of a primitive in Target UNF is that it should be the Jacobian of
the corresponding term in Target. This is easily checked for scalar operations.  

\begin{proposition}
    \begin{center}
\begin{tabular}{r c l}
    !$\seml\UNFSymbol^{-1}(J^T$map2$_{x,y.e})\semr$! &=& !$J^T\seml\UNFSymbol^{-1}($map2$_{x,y.e})\semr$!\\
    !$\seml\UNFSymbol^{-1}(J^T$reduce$_{x,y.e_1;e_2})\semr$! &=& !$J^T\seml\UNFSymbol^{-1}($reduce$_{x,y.e_1;e_2})\semr$!
\end{tabular}
\end{center}
\end{proposition}

This is proved in Appendix \ref{sub:Reverse derivative of array operations}.

From this, we now deduce that the composite transformation $\UNFSymbol$, $\Dsynrevsymbol_{\rho}$, $\UNFSymbol^{-1}$ is correct
in the sense that it produces a term that computes the gradient of the original term.

\begin{proposition}
    If !x$_1:\reals$,$\ldots$,x$_n:\reals$ $\vdash$ e: $\reals$! then \\
    $\seml \pi_2 \UNFSymbol^{-1}(\Dsynrevsymbol_{\rho}(\UNFSymbol($!e!$)))\semr(x_1,\ldots x_n,Id_{\RR^n})$=$J^T_{(x_1,\ldots x_n)}$!<!$Id_{\RR^n}$,$\seml$!e!$\semr$!>!
\end{proposition}

\begin{proof}
    TODO
\end{proof}

By inspecting what that composition of transformations does on terms of Source, 
we show that this indeed gives computes the same as the transformation 
$\directD{\rho}{\Gamma}{Y}$ from Section~\ref{sub:Macro for pure reverse mode transformation}. 

\begin{proposition}
    $\seml\UNFSymbol^{-1}(\Dsynrevsymbol_{\rho}(\UNFSymbol($!e!$)))\semr$ = $\seml\directD{\rho}{\Gamma}{Y}($!e!$)\semr$ 
\end{proposition}

\begin{proof}
    TODO
\end{proof}

Combining the the previous propositions, we have shown that $\directD{\rho}{\Gamma}{Y}$ is correct.

\begin{theorem}
    For every $\Gamma \vdash$ !e:!$\reals$, we have 
    $\sem{\grad_\Gamma e}= \grad_\Gamma\sem{e}$.
\end{theorem}