\section{Correctness}
\label{sec:correctness}

This section provides a categorical analysis of our language and transformations.
The main result at the end of section is the correctness of the reverse mode transformation from Section~\ref{sub:Macro for pure reverse mode transformation}:

 \begin{theorem}
     For every $\Gamma \vdash$ !e:!$\reals$, we have 
     $\sem{\grad_\Gamma e}= \grad_\Gamma\sem{e}$.
 \end{theorem}
where $\sem{-}$ is an appropriate denotational semantics of smooth functions.

\subsection{Denotational semantics} % (fold)
\label{sub:Denotational semantics source and Target}

A multicategory generalizes a category by allowing multimorphisms, that is, morphisms from a list of objects to an object.
Most categorical structures from category theory can be phrased similarly in multicategories.
It is standard to give a denotational semantics of a first-order language in a Cartesian category, and alternatively in a multicategory.

A term $x_1:A_1,\ldots,x_n:A_n\vdash e:A$ is interpreted as a morphism $\sem{e}:[\sem{A_1},\ldots,\sem{A_n}]\to \sem{A}$ in a multicategory.
Substitution is interpreted as composition. We first consider a syntactic model for a language, which consists of a 
free multicategy on some base types and primitives. Our source and target languages induce syntactic multicategories as follows.

\begin{definition}[Syntactic multicategory for Source]
    Let $\SynSource$ be the multicategory whose objects are types of Source, and where a morphism 
    $[A_1,\ldots,A_n]\to A$ is a term $x_1:A_1,\ldots,x_n:A_n\vdash e:A$ of Source modulo the $\eta\beta$-laws.
    Composition is by substitution.
\end{definition}

We similarly define $\SynTarget$, the syntactic multicategory for Target.

$\SynSource$ satisfies the following universal property: 
for every Cartesian multicategory $\catC$,
and every object $F(\reals)\in\catC$, morphisms $F(\underline{c})\in\catC(1;F(\reals))$, 
$F(op1)\in\catC(F(\reals);F(\reals))$, $F(op2)\in\catC(F(\reals),F(\reals);F(\reals))$, 
there is a unique multifunctor $F:\SynSource\to\catC$ respecting the interpretation and preserving all the categorical structure. 

This allows us to give a simple semantics of Source 
in the multicategory of Cartesian spaces and smooth maps between them. 

\begin{definition}[$\CartSp$]
Let $\CartSp$ be the Cartesian multicategory whose objects are Euclidean spaces
and whose morphisms $[A_1,\ldots,A_n]\to B$ are smooth functions $A_1\times\ldots A_n \to B$.

We interpret Source in $\CartSp$ as follows. A context $\Gamma=\{x_1:A_1,\ldots,x_n:A_n\}$ is interpreted as the product $\prod_{1\leq i \leq n}\sem{A_i}$.
Well typed terms $\Gamma\vdash$!e: !$A$ are interpreted as functions $\sem{\Gamma}\to\sem{A}$.

    \begin{tabular}{r c l}
    $\seml \reals \semr$ & $\defeq$& $\RR$ \\
    $\seml$!T1xT2!$\semr$ & $\defeq$& $\seml$!T1!$\semr \times\seml$!T2!$\semr$ \\
    $\seml \Array{\reals}{n}\semr$ & $\defeq$ & $\prod_{1\leq i \leq n} \RR$ \\
    !$\seml$op1$\semr$! & $\defeq$ & op1: $\reals\to\reals$ 
    \end{tabular}
    \begin{tabular}{r c l} 
        !$\seml$op2$\semr$! & $\defeq$ & op2: $\reals\times \reals\to\reals$ \\
        !$\seml$c$\semr$! & $\defeq$ & $c\in\RR$ \\
        !$\seml$map2 (x,y.e$_1$) e$_2$ e$_3\semr_\gamma$ ! & $\defeq$ & TODO \\
        !$\seml$reduce (x,y.e$_1$) e$_2$ e$_3\semr_\gamma$! & $\defeq$ &
    \end{tabular}

Variables are interpreted as projections, let binding uses composition in the multicategory. 
Pairs are interpreted using the Cartesian structure of the multicategory.
\end{definition}

We can similarly interpret Target in a multicategory of smooth-like spaces and functions. 
However, Target is higher-order but $\CartSp$ is not Cartesian Closed. 
Instead, we can for instance interpret Target in the category of Diffeological spaces, 
as in \cite{huot2020correctness}. 
Diffeological spaces (\cite{iglesias2013diffeology}) are a conservative extension of $\CartSp$. 
The key idea will be that a higher order function is called smooth if it sends smooth functions to smooth functions, meaning that we can never use it
to build first order functions that are not smooth.

\begin{definition}
	A \emph{diffeological space} $(X,\plots{X})$ consists of a set $X$ together with, for each $n$ and each open subset $U$ of $\RR^n$,  a set $\plots{X}^U\subseteq [U\to X]$ of functions, called \emph{plots}, such that
	\begin{itemize}
	 	\item all constant functions are plots;
	 	\item if $f:V\to U$ is a smooth function and $p\in\plots{X}^U$, then $f;p\in\plots{X}^V$;
     \item if $\seq[i\in I]{p_i\in\plots{X}^{U_i}}$ is a compatible family of plots $(x\in U_i\cap U_j\Rightarrow p_i(x)=p_j(x))$
     and $\seq[i\in I]{U_i}$ covers $U$,
     then the gluing $p:U\to X:x\in U_i\mapsto p_i(x)$ is a plot.
	 \end{itemize} 
\end{definition}
We call a function $f:X\to Y$ between diffeological spaces \emph{smooth} if, for all plots
$p\in\plots{X}^U$, we have that $p;f\in \plots{Y}^U$. We write $\Diff(X,Y)$ for the set of smooth maps from $X$ to $Y$. 
Smooth functions compose, and so we have a category $\Diff$ of diffeological spaces and smooth functions.

A diffeological space is thus a set equipped with structure.
Many constructions of sets carry over straightforwardly to diffeological spaces.

\begin{example}[Cartesian diffeologies]\label{ex:cartesian-diffeologies}
Each open subset $U$ of $\RR^n$ can be given the structure of a diffeological space by taking all the
smooth functions $V\to U$ as $\plots{U}^V$.
It is easily seen that smooth functions from $V\to U$ in the traditional sense coincide with
smooth functions in the sense of diffeological spaces.
Thus diffeological spaces have a profound relationship with ordinary calculus.
\end{example}

\begin{example}[Product diffeologies]
Given a family $\seq[i\in I]{X_i}$ of diffeological spaces,
we can equip the product $\prod_{i\in I}X_i$ of sets with the
\emph{product diffeology} in which $U$-plots are precisely the functions
of the form $\seq[i\in I]{p_i}$ for $p_i\in\plots{X_i}^U$.  
\end{example}

\begin{example}[Functional diffeology]
We can equip the set $\Diff(X,Y)$ of smooth functions between diffeological spaces with the \emph{functional diffeology}
in which $U$-plots consist of functions $f:U\to \Diff(X,Y)$ such that 
$(u,x)\mapsto f(u)(x)$ is an element of $\Diff(U\times X, Y)$.
\end{example}

We can thus interpret function types !$\seml$A -> B$\semr$! = $\Diff$($\seml$!A!$\semr$,$\seml$!B!$\semr$).

\subsection{Semantics for UNF languages with concategories} % (fold)
\label{sub:Semantics for UNF using concategories}

One main reason for introducing UNF is to have a better handle over
the computation flow of the term, similarly to what the ANF or CPS transformations do.
A convenient categorical setting for this is to use string diagrams.
To better fit the standard denotational semantics of languages, 
we can instead use concategories. 

Concategories are a generalization of categories and multicategories in that 
they allow morphisms both from and to a list of objects. 
Similarly to categories and multicategories, 
most categorical construtions used for the semantics of functional languages 
have equivalent in concategories.

In particular, one can form a syntactic concategory on some base types and primitives, 
which satisfies a similar universal property as syntactic multicategories.
Two partiular examples are of interest for us, as they will allow us to interpret Source and Target UNF
but they will also help us explain the UNF and $UNF^{-1}$ transformations.

\begin{definition}[$\ConcatS$]
Let $\ConcatS$ be the syntactic Cartesian concategory whose types are those of Source and 
with primitives given by $op1: \reals \to \reals$, $op2: \reals,\reals \to \reals$, 
TODO: $map2_{x,y.e}$and $reduce_{x,y.e1;e2}$.
\end{definition}

One may notice that the syntax of $\ConcatS$ is somewhere in between the syntax of Source and of Source UNF.

\begin{notation}[Morphisms in a Cartesian concategory]
    TODO: projection, unique map, $\concatcomp$, swap, pair, id, ...
\end{notation}

We can interpret Source UNF in $\ConcatS$ as follows.

\begin{tabular}{l c l}
   $\seml$!var!$_{T;i} \semr$ &=& $<id_\Gamma,\pi_i>$ \\
   $\seml$!op!$_{T;n} \semr$ &=& $id_\Gamma\concatcomp op_n$\\
   $\seml$!pair!$_{T;A\times B} \semr$ &=& $pair_{T;A\times B}$ \\
   $\seml$!proj!$_{T1;T2;T3} \semr$ &=& $id_{T1}\concatcomp 1_{T2}\concatcomp id_{T3}$\\
   $\seml$!e1!$\comp$!e2!$\semr$  &=& $\seml$!e1!$\semr \comp \seml$!e2!$\semr$ \\
   $\seml$!e1!$\pcomp$!e2!$\semr$ &=& $\seml$!e1!$\semr \comp (\seml$!e2!$\semr\concatcomp id )\comp swap$ \\
   $\seml$!map2!$_{T;x,y.e}\semr$  &=& $id_\Gamma\concatcomp map2_{x,y.e}$ \\
   $\seml$!reduce!$_{T;x,y.e;e}\semr$ &=& $id_\Gamma\concatcomp reduce_{x,y.e1;e2}$ \\
\end{tabular}

Similarly, we introduce a second concategory for the Target part of our transformations.

\begin{definition}[$\ConcatT$]
Let $\ConcatT$ be the syntactic Cartesian concategory whose types are those of Target and 
whose primitives are given by 
$op1: \reals \to \reals$, 
$op2: \reals,\reals \to \reals$, 
$map2_{x,y.e}: \Array{\reals}{n},\Array{\reals}{n}\to \Array{\reals}{n}$, 
$reduce_{x,y.e1;e2}: \Array{\reals}{n} \to \Array{\reals}{n}$, 
$J^Top1: \reals \to \reals$, 
$J^Top2: \reals \to \reals, \reals$, 
$J^Tmap2_{x,y.e}: \Array{\reals}{n} \to \Array{\reals}{n}, \Array{\reals}{n}$, 
$J^Treduce_{x,y.e1;e2}: \Array{\reals}{n} \to \Array{\reals}{n}$ 
\end{definition}

We can interpret Target UNF in $\ConcatT$ as follows. 
The part common with Source UNF is interpreted in the same way as for the case of Source UNF.

TODO: I think need to explain here the (co)monoid structure induced by $\Dsynrevsymbol_{\rho}$ 

\begin{tabular}{l c l}
    $\seml$!J!$^T$!var!$_{T;i} \semr$ &=& TODO \\
    $\seml$!J!$^T$!op!$_{T;n} \semr$ &=& $id_T\concatcomp J^Top_n$ \\
    $\seml$!J!$^T$!pair!$_{T;A\times B} \semr$ &=& $id_T\concatcomp$!<$\pi_1,\pi_2$>! \\
    $\seml$!J!$^T$!proj!$_{T1;T2;T3} \semr$ &=& $id_{T_1}\concatcomp\widehat{0}_{T_2}\concatcomp id_{T_3}$ \\
    $\seml$!J!$^T$!map2!$_{T;x,y.e}\semr$  &=& $id_T\concatcomp map2_{T;x,y.e}$ \\
    $\seml$!J!$^T$!reduce!$_{T;x,y.e_1;e_2}\semr$  &=& $id_T\concatcomp reduce_{T;x,y.e_1;e_2}$ \\
    $\seml$!<e$_1$, e$_2$>!$\semr$  &=& !<!$\seml$!e1!$\semr$, $\seml$!e2!$\semr$!>! \\
    $\seml$!e$_1$!$\icomp$!e$_2$!$\semr$ &=& $\Lambda$($id_\Gamma\concatcomp\seml$!e2!$\semr$; $\Lambda^{-1}$($\seml$!e1!$\semr$)) \\
 \end{tabular}

\subsection{Semantics of $\UNFSymbol$ transformations} % (fold)
\label{sub:Semantics for UNF transformations}

We interpret Source in a new multicategory, 
whose morphisms are particular morphisms of $\ConcatS$.
As Source UNF is itself interpreted in $\ConcatS$, 
this gives us a way to compare terms in Source with terms in Source UNF.
This comparison precisely gives the UNF transformation.

\begin{definition}[Mutlicat from concat]
    We define $\CSource$ to be the multicategory with the same objects as Source and 
    $\CSource([A_1,\ldots,A_n],B)=\ConcatS([A_1,\ldots,A_n],[A_1,\ldots,A_n,B])$.
\end{definition}

\begin{proposition}[construction above gives UNF]
    TODO
\end{proposition}

In a similar vein, we form a concategory from the syntactic multicategory for Target.
We then use the universal property of $\ConcatT$ to construct a functor from $\ConcatT$ to this concategory.
This allows us to compare the terms of Target UNF and the terms of Target. 
$UNF^-1$ arises in this way.

\begin{definition}[Concat from multicat]
    A multicategory $\catC$ naturally defines a concategory with the same objects as $\catC$ and
    with morphisms $A\to [B_1,\ldots,B_n]$ being $n$ morphisms $A\to Bi$ of $\catC$. 
\end{definition}

\begin{proposition}[Initiality of concat2 gives $UNF^-1$]
    TODO
\end{proposition}

What remains to explain now is the reverse mode transformation between Source UNF and Target UNF.
We construct a functor $\Dsynrevsymbol_{\rho}:\ConcatS\to\ConcatT$. 
This functor will easily be shown to compute reverse-mode derivatives.
Because terms of Source UNF in $\ConcatS$, we observe the effect of $\Dsynrevsymbol_{\rho}$ on them
and show that it matches the syntactic $\Dsynrevsymbol_{\rho}$ 
from Section~\ref{sub:Simple reverse mode transformation}.

\begin{definition}[D as a lax functor]
    TODO
\end{definition}

The design of $\Dsynrevsymbol_{\rho}$ on UNF is inspired by the semantic one between concategories, 
and it's routine to check that they match. 

\begin{proposition}[semantic of syntactic D matches D lax functor]
    Given a well typed term !T$_1$ $\vdash$ e: T$_2$! in Source UNF, we have
    \begin{center}
        $\seml\Dsynrevsymbol_{\rho}$!e!$\semr$ = $\Dsynrevsymbol_{\rho}\seml$!e!$\semr$
    \end{center}
\end{proposition}

In summary, we have the following picture

\[
\begin{tikzcd}
    SourceUNF \ar[r,"\sem{-}"] & Concat1 \ar[r,"\Dsynrevsymbol_{\rho}"] & Concat2 \ar[r,"\UNFSymbol^{-1}"] & C_{Target} \\
    Source \ar[r,"\UNFSymbol"] & \CSource \ar[u, hook] & TargetUNF \ar[u,"\sem{-}"] & Target \ar[u, hook] 
\end{tikzcd}
\]

\subsection{Correctness theorem} % (fold)
\label{sub:Correctness theorem}

First, we start from the correctness of $\Dsynrevsymbol_{\rho}$:Source UNF $\to$ Target UNF, which is easy to establish, 
and then propagate this information to Source and Target via the $\UNFSymbol$ and $\UNFSymbol^{-1}$ transformations.

\begin{proposition}[Correctness $\Dsynrevsymbol_{\rho}$]
    For every term !$\reals^{\times n} \vdash$ e: $\reals^{\times n+1}$! in Source UNF,
    \begin{center}
        $\pi_2 \seml \Dsynrevsymbol_{\rho}$!e!$\semr(x_1,\ldots x_n,Id_{\RR^n})$=$J^T_{(x_1,\ldots x_n)}\seml$!e!$\semr$
    \end{center} 
\end{proposition}

This is routinely proved by induction as the language is first-order. 
This uses the fact that for every primitive constant $A$, $\sem{J^TA}=J^T\sem{A}$.

Recall that the intuition from Source UNF is that it consists of terms of Source that also return their context.
From there, the intuition for the Jacobian of a primitive in Target UNF is that it should be the Jacobian of
the corresponding term in Target. This is easily checked for scalar operations. For the more difficult cases, we have 

\begin{proposition}
$\UNFSymbol^{-1}$ preserves the semantics of Jacobians of !map2! and !reduce!.
    \begin{center}
\begin{tabular}{r c l}
    !$\seml\UNFSymbol^{-1}(J^T$map2$_{x,y.e})\semr$! &=& !$J^T\seml\UNFSymbol^{-1}($map2$_{x,y.e})\semr$!\\
    !$\seml\UNFSymbol^{-1}(J^T$reduce$_{x,y.e_1;e_2})\semr$! &=& !$J^T\seml\UNFSymbol^{-1}($reduce$_{x,y.e_1;e_2})\semr$!
\end{tabular}
\end{center}
\end{proposition}

This is proved in Appendix \ref{sub:Reverse derivative of array operations}.

From this, we now deduce that the composite transformation $\UNFSymbol$, $\Dsynrevsymbol_{\rho}$, $\UNFSymbol^{-1}$ is correct
in the sense that it produces a term that computes the gradient of the original term.

\begin{proposition}
    If !x$_1:\reals$,$\ldots$,x$_n:\reals$ $\vdash$ e: $\reals$! then \\
    $\seml \pi_2 \UNFSymbol^{-1}(\Dsynrevsymbol_{\rho}(\UNFSymbol($!e!$)))\semr(x_1,\ldots x_n,Id_{\RR^n})$=$J^T_{(x_1,\ldots x_n)}$!<!$Id_{\RR^n}$,$\seml$!e!$\semr$!>!
\end{proposition}

By inspecting what that composition of transformations does on the terms of Source, 
we show that this indeed gives computes the same as the transformation 
$\directD{\rho}{\Gamma}{Y}$ from Section~\ref{sub:Macro for pure reverse mode transformation}. 
This should not come as a surprise because the design of $\directD{\rho}{\Gamma}{Y}$ was in fact guided via 
this decomposition and intermediate representation.

\begin{proposition}
    $\seml\UNFSymbol^{-1}(\Dsynrevsymbol_{\rho}(\UNFSymbol($!e!$)))\semr$ = $\seml\directD{\rho}{\Gamma}{Y}($!e!$)\semr$ 
\end{proposition}

Combining the the previous propositions, we have shown that $\directD{\rho}{\Gamma}{Y}$ is correct.

\begin{theorem}
    For every $\Gamma \vdash$ !e:!$\reals$, we have 
    $\sem{\grad_\Gamma e}= \grad_\Gamma\sem{e}$.
\end{theorem}