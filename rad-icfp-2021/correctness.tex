\section{Correctness}
\label{sec:correctness}

This section provides a categorical analysis of our language and transformations.
The end result is the correctness of the reverse mode transformation from Section~\ref{sub:Macro for pure reverse mode transformation}:

 \begin{theorem}
     For every $\Gamma \vdash$ !e:!$\reals$, we have 
     $\sem{\grad_\Gamma e}= \grad_\Gamma\sem{e}$.
 \end{theorem}
where $\sem{-}$ is ab appropriate denotational semantics of smooth functions.

\subsection{Denotational semantics source and Target} % (fold)
\label{sub:Denotational semantics source and Target}

It is standard to give a denotational semantics of a first-order language in a Cartesian category.
An alternative approach consists in giving a semantics in a multicategory.
A multicategory generalises a category by allowing multimorphims, that is morphisms from a list of objects to an object.
Most categorical structures from category theory can be phrases similarly in multicategories.

In terms of semantics, a term $x_1:A_1,\ldots,x_n:A_n\vdash e:A$ is interpreted as a morphism $\sem{e}:[\sem{A_1},\ldots,\sem{A_n}]\to \sem{A}$ in a multicategory.
Substitution is still interpreted as composition. 

One can consider a syntactic model for a language, which consists in a free multicategory.
Our source and target languages induce syntactic multicategories as follows.

\begin{definition}{Syntactic multicategory for Source}
    Let $\SynSource$ be the multicategory whose objects are types of Source, and where a morphism 
    $[A_1,\ldots,A_n]\to A$ is a term $x_1:A_1,\ldots,x_n:A_n\vdash e:A$ of Source modulo the $\eta\beta$-laws.
    Composition is by substitution.
\end{definition}

We similarly define $\SynTarget$, the syntactic multicategory for Target.

As is standard, $\SynSource$ satisfies the following universal property: 
for every Cartesian multicategory $\catC$ with arrays map and reduce,
and every object $F(\reals)\in\catC$ and morphisms $F(\underline{c})\in\catC(1;F(\reals))$, 
$F(op1)\in\catC(F(\reals);F(\reals))$, $F(op2)\in\catC(F(\reals),F(\reals);F(\reals))$, there is a unique
multifunctor $F:\SynSource\to\catC$ respecting the interpretation and preserving all the structure.

We can for instance use this to give a simple semantics of Source 
in the multicategory of Cartesian spaces and smooth maps between them. 

\begin{definition}{CartSp}
    TODO, its definition and semantics of Source in it.
\end{definition}

TODO: what about semantics Target?

\subsection{Semantics for UNF using concategories} % (fold)
\label{sub:Semantics for UNF using concategories}

One main reason for introducing UNF is to have a better control 
of the computation flow of the term, similarly to what ANF or CPS do. 
A convenient categorical setting for this is to use string diagrams.
To better fit the standard denotational semantics of languages, 
we can instead use concategories. 

Concategories are a generalisation of categories and multicategories in that 
they allow morphisms both from and to a list of objects. 
Similarly to categories and multicategories, 
most categorical abstractions used for the semantics of languages are easily adapted to them.

In particular, one can form a syntactic concategory, 
which satisfies a similar universal property as syntactic multicategories.
Two such examples are of particular interest for us, 
because they will allow us to interpret Source and Target UNF, 
but also explain the UNF and $UNF^{-1}$ transformations.

\begin{example}{Concat1}
    TODO
\end{example}

We can interpret Source UNF in $\ConcatS$ as follows.

TODO

Similarly, we introduce a second concategory for the Target part.

\begin{example}{Concat2}
    TODO
\end{example}

We can interpret Target UNF in $\ConcatT$ as follows.

TODO

\subsection{Semantics for UNF transformations} % (fold)
\label{sub:Semantics for UNF transformations}

We interpret Source in a new multicategory, 
whose morphisms are particular morphisms of $\ConcatS$.
As Source UNF is itself interpreted in $\ConcatS$, 
this gives us a way to compare terms in Source with terms in Source UNF.
This comparison precisely give the UNF transformation.

\begin{definition}{Mutlicat from concat}
    TODO
\end{definition}

\begin{proposition}{construction above gives UNF}
    TODO
\end{proposition}




\begin{definition}{Concat from multicat}
    TODO
\end{definition}

\begin{proposition}{Initiality of concat2 gives $UNF^-1$}
    TODO
\end{proposition}






\begin{definition}{lax functor between concat}
    TODO
\end{definition}


\begin{example}{D as a lax functor}
    TODO
\end{example}

\begin{proposition}{semantic of D syntactic matches D lax functor}
    TODO
\end{proposition}


\subsection{Correctness theorem} % (fold)
\label{sub:Correctness theorem}

\begin{proposition}{The transpose Jacobian of !map2! and !reduce! are correct.}
    TODO
\end{proposition}

\begin{theorem}{UNF;D;$UNF^-1$ correct}
    TODO
\end{theorem}

\begin{proposition}{UNF;D;$UNF^-1$=D}
    TODO
\end{proposition}

\begin{theorem}{D is correct}
    TODO
\end{theorem}