\section{Simple reverse-mode differentiation}
\label{sec:simplediff}

\subsection{Source Language} 

We consider a standard call-by-value language. 
It is a first-order language with array constructs and a few typical second-order array operations. 
The types !T1,T2! and terms !e1,e2! are in Figure~\ref{fig:source_grammar}.

\input{figures/source_grammar}

The typing rules are in Figure~\ref{fig:source_typesystem}. We have included a minimal set of array operations for the sake of illustration, 
but it is not difficult to add further operations. For scalar operations, we assume given a set of operations. 
!op1! and !op2! denote respectively unary and binary smooth operations on reals. 
We use infix notation for binary operators.
Typical examples include !cos, exp, +, *!. 
For the sake of simplicity in the development, the function in the array operations !map, map2, foldl! are quite restricted with and free variables. 
We also restrict to arrays of reals.
The general case is also useful and presented in Section~\ref{sec:generalisation}.

\input{figures/source_type_system}

\subsection{Source Unary Form} 

Following the intuition highlighted in Section~\ref{subsec:insights}, we present a new language which we call unary form (UNF). 
It simply consists of a composition of unary operators. That said, we want to compile our source language to this intermediate representation, 
and we need to remember some information about the initial term. 

The grammar of our source UNF is given in Figure~\ref{fig:unf_source_grammar}. 

\input{figures/source_unf}

There are a few notable things in this syntax. 
Every term is indexed by a well-defined contex $\Gamma$ from the source language.
In addition, a variable has a integer index $1\leq i\leq n$ where $n$ is the size of the context $\Gamma$.
Every constant, unary, or binary operator is summarised as an $n$-ary operator !op!$_n$.
Sequential composition is denoted by !;! and !e1;e2! means that !e1! should be performed, and then !e2!.
Every array operator !map!, !map2! and !foldl! has an extra index which represents a well-formed term in the source language.

The types are the same as in the source language. 
A context $\Gamma=\{$!x1: T1,...,xn:Tn!$\}$ can always be seen as a type !T1!$\times$...$\times$!Tn!.
UNF is very syntactic and does not really use variables. 
In fact it consists only of constants and composition. 
For this reason, we denote contexts as types in the indices of the terms, and $\times$ is used for context extension.
But we do emphasize that we mean contexts and the actual variables are remembered and
this will be key when compiling to the target language after differentiation. 

The typing rules are detailed in Figure~\ref{fig:source_unf_typesystem}.
By $\reals^{\times n}$ we mean the product $\reals\times...\times\reals$ of $n$ factors $\reals$.

\MH{need to explain that return values produce some kind of ANF and introduce new vars!}

\input{figures/source_unf_typesystem}

We give a translation from our source language to source UNF in Figure~\ref{fig:source_to_unf}.
UNF acts as a sort of stack. 
The input represents the current stage of the stack, and we return the new value added to the stack.
All results are kept, so the stack keeps growing. One might be surprised that the transformation for pairs and let is similar.
The order of UNF really follows what the trace of doing a sequential call-by-value evaluation would look like if the return value does not matter.
In other words, when evaluating !let x= e1 in e2! in call by value, we first evaluate !e1! and then !e2!. 
Similarly in !<e1, e2>!, we evaluate !e1! and then !e2!. 
Our ultimate goal is to return a gradient, not the original term, so what really matters is the order of evaluation, and what is evaluated.

$\widehat{;}$ is similar to $;$, with a sort of context propagation effect. 
It is a bit reminiscent of monadic composition versus the usual composition.
Technically though, the transformation $\UNFSymbol$ is not quite compositional.
\MH{explain in detail how to define it.}   

\begin{proposition}
    Let $\Gamma\vdash$!e!: !T! be a term in the source language.\\
    Then $\Gamma \vdash \UNFSymbol$(!e!): $\Gamma\times\Delta\times$!T! in source UNF for a certain type $\Delta$. 
\end{proposition}

$\Delta$ corresponds to the list of all the intermediate results from !e!. 
A different way to say it would be that $\Delta$ is the context made of the bound variables of !e! when !e! is in ANF.

\input{figures/source_to_unf}

\subsection{Target Unary Form}

Now our program in UNF is in an equivalent form to straight-line programs. 
Before presenting our differentiation macro, we present the target language for this macro. 
We call this intermediate representation target UNF.
The main idea is similar to source UNF where we only have constants and sequential composition.
That said, the key difference is that now every constant represents a pair of an operation and what is meant to represent its Jacobian.
Following the insights from Section~\ref{sec:background}, the composition of pairs reverses the order on the second component. T
his represents the fact that reverse-mode reverts the computation flow, 
and that pre-composition (using a continuation) is the simplest way to do this in a purely functional setting.
On pairs, !;! still represents sequential composition for the first component, and reversed composition is represented by $\circ$ on the second component.
The grammar and types are given in Figure~\ref{fig:unf_target_grammar}. 
For every constant $C$ from the source UNF, we have a new constant $J^TC$ representing its transpose Jacobian.
One thing to note is that one can only form pairs in this language. 
Similarly to the source UNF, sequential composition is the only operation which is not a constant of the language.

\input{figures/target_unf}

Technically, all our terms in target UNF should have an extra index $\rho$ which is a type from Source.
This will be the return type of the continuation for the jacobian accumulation. 
In other words, if we want the full gradient of a term $\Gamma\vdash$!e!: $\reals$, $\rho$ should be chosen to be $\Gamma$.
For every type !T!, let $\Dtype$(!T!)$:=$!T!$\times$(!T!->$\rho$). 
The typesystem is given in Figure~\ref{fig:target_unf_typesystem}. 

\input{figures/target_unf_typesystem}

\subsection{Macro for reverse mode}

We are now able to present a simple transformation for purely functional reverse-mode on UNF.
This transformation is somehow straightforward as some of the work was put into the design of UNF.
Our main takeaway for this paper is that reverse-mode is complicated because there is a lot happening at the same time. 
But by decoupling the problems, it becomes much easier. UNF is somehow dealing with the inherent type-dependency of reverse-mode.
Then the macro $\Dsynrevsymbol$ adds Jacobians. It allows to compute gradients in a compositional way.
Finally, we'll see in the next section how to compile back to a more standard language and optimize our transformation to get efficiency.

The differentiation macro is given in Figure~\ref{fig:diff_macro}.
One might be surprised that the macro does not seem to do much, and it is partly correct.
We tried to decompose reverse-mode into more elementary small steps, and each step is slightly non trivial and dealing with one aspect of reverse-mode.
The perhaps slightly more involved transformation is the one coming next,  going from target UNF to our target language.

\input{figures/macro_diff}

Even though the target UNF is designed to achieve this purpose, we have the Following

\begin{proposition}
    If $\Gamma \vdash$!e!: !T! in source UNF, then
    $\Dtype(Gamma)\vdash \Dsynrevsymbol$(!e!):  $\Dtype$(!T!) in target UNF.
\end{proposition}
